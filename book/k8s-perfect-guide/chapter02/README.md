# k8s
쿠버네티스는 컨테이너화된 애플리케이션의 배포 확장 등을 관리하는 것을 자동화하기 위한 플랫폼이다 (컨테이너 오케스트레이션 엔진)

컨테이너 오케이스트레이션 엔진에는 도커 스윔, 아파치 메소스등이 있다

k8s에서 사용할 수 있는 컨테이너 런타임은 도커 이외에 containerd, cri-o 등이 있다 

쿠버네티스에서 실제 컨테이너가 기동하는 노드(호스트가 되는 물리머신이나 가상머신)는 쿠버네티스 노드라 하고, 그 쿠버네티스 노드를 관리하는 노드는 쿠버네티스 마스터라 한다.

# 할 수 있는 것

## IAC
yaml 형식이나 json 형식으로 작성한 선언적 코드(manifest)를 통해 배포하는 컨테이너로 주변 리소스를 관리할 수 있어 IaC를 구현할 수 있다.

## 스케일링/오토 스케일링
부하 분산 및 다중화 구조를 만들 수 있다

부하에 따라서 컨테이너 오토 스케일링을 진행할 수 있다

## 스케쥴링
컨테이너를 쿠버네티스 노드에 배포할 때 어떤 쿠버네티스 노드에 배포할 것인지를 결정하는 '스케쥴링'단계가 있다.
Affinity와 Anti Affinity 기능을 사용하여 컨테이너화된 애플리케이션 워크로드의 특징이나 쿠버네티스 노드의 성능을 기준으로 스케쥴링할 수 있다

## 리소스 관리
스케쥴링 설정이 특별히 없을 경우 쿠버네티스 노드의 리소스 상태에 따라 스케쥴링된다

리소스 사용 상태에 따라 클러스터 오토 스케일링 기능으로 쿠버네티스 클러스터의 쿠버네티스 노드도 자동으로 추가하거나 삭제할 수 있다

## 자동화된 복구
쿠버네티스는 표준으로 컨테이너 프로세스를 모니터링하고 프로세스 정지를 감지한다 프로세스 정지를 감지하면 다시 컨테이너 스케쥴링을 실행하여 컨테이너를 자동으로 배포한다

자동화된 복구 실행 조건에는 프로세스 모니터링 외에 http/tcp나 쉘 스크립트로 헬스 체크의 성공 여부를 설정할 수도 있다

## 로드 밸런싱과 서비스 디스커버리
쿠버네티스는 로드밸런서 기능을 제공한다
- service
- ingress

사전에 정의한 조건과 일치하는 컨테이너 그룹에 라우팅하는 엔드포인트를 할당할 수 있다

컨테이너를 확장할 때 엔드포인트가 되는 서비스에 컨테이너의 자동 등록과 삭제, 컨테이너 장애 시 분리, 컨테이너 롤링 업데이트 시 필요한 사전 분리 작업도 자동으로 실행해준다

쿠버네티스 서비스를 사용하면 서비스 디스커버리도 가능하다  

## 데이터 관리
쿠버네티스는 백엔드 데이터 스토어로 etcd를 채용하고 있다. 
etcd는 클러스터를 구성하여 이중화가 가능하고 컨테이너나 서비스의 매니페스트 파일도 이중화 구조로 저장한다.

쿠버네티스는 컨테이너가 사용하는 설정 파일이나 인증 정보 등의 데이터를 저장하는 구조도 가지고 있어 컨테이너
공통 설정이나 애플리케이션에서 사용되는 데이터베이스 인증 정보 등을 안전하고 이중화된 상태로 쿠버네티스에서 집중적으로 관리할 수 있다

# 쿠버네티스를 지원하는 미들웨어
쿠버네티스는 외부 에코시스템과의 연계도 활발히 이루어지고 있다

- **Ansible** 컨테이너 배포
- **Apache** Ignite 서비스 디스커버리를 사용한 클러스터 생성과 스케일링
- **Fluentd** 컨테이너 로그 전송
- **GitLab** ci/cd 
- **Jenkins** job 실행 시 job 실행자용 컨테이너를 k8s에 배포
- **OpenStack** 클라우드 사업자와 연계한 k8s 구축
- **Prometheus** 모니터링
- **Spark** job을 k8s에서 네이티브로 실행(yarn 대체)
- **Spinnaker** 컨테이너 배포
- **Kubeflow** ML 플랫폼 배포
- **Rook** 분산 파일 시스템 배포
- **Vitess** MySQL 클러스터 배포
- 등등
